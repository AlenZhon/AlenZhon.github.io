<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>HashMap与TreeMap, LinkedHashMap, ConcurrentHashMap的简单比较</title>
    <url>/2020/04/09/HashMap2/</url>
    <content><![CDATA[<a id="more"></a>
<h2 id="TreeMap的优缺点"><a href="#TreeMap的优缺点" class="headerlink" title="TreeMap的优缺点"></a>TreeMap的优缺点</h2><p>优点： 底层采用红黑树，支持自定义实现的比较器，支持排序；存储空间无冗余，一个TreeNode节点对应一个键值对。<br>缺点：查询的时间复杂度由于红黑树结构限制为O(logN)；增加或删除节点的时候会导致红黑树的重排。</p>
<h2 id="存储结构的比较"><a href="#存储结构的比较" class="headerlink" title="存储结构的比较"></a>存储结构的比较</h2><ul>
<li><code>HashMap</code>：数组+链表+红黑树</li>
<li><code>LinkedHashMap</code>：与HashMap相同，同时维护一个根据插入顺序保持的双向链表（迭代遍历时用到）。</li>
<li><code>TreeMap</code>: 红黑树</li>
<li><code>ConcurrentHashMap</code>：和<code>HashMap</code>相同。但用<code>TreeNode</code>节点的包装对象<code>TreeBin</code>代替了红黑树对象。</li>
</ul>
<h2 id="有序："><a href="#有序：" class="headerlink" title="有序："></a>有序：</h2><ul>
<li>HashMap，ConcurrentHashMap无序</li>
<li>LinkedHashMap 根据插入先后顺序确定遍历顺序</li>
<li>TreeMap 有序，根据Key进行比较获取先后顺序</li>
</ul>
<h2 id="迭代："><a href="#迭代：" class="headerlink" title="迭代："></a>迭代：</h2><ul>
<li>HashMap调用HashIterator的nextNode方法</li>
</ul>
<ol>
<li>从头开始遍历数组</li>
<li>若数组中该索引处为null，或者Node的next指向null，则扫描数组的下一位</li>
<li>若数组中该索引处非null，切Node的next指向另一个Node，则依次扫描Node的next元素，直到为null</li>
</ol>
<ul>
<li>LinkedHashMap 调用LinkedHashIterator的nextNode方法，从head头指针触发遍历双向链表直到tail。</li>
<li>TreeMap按照树的中序遍历扫描。</li>
</ul>
<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>这几种只有ConcurrentHashMap线程安全。HashTable的线程安全性是在各个方法上加synchronized关键字实现的。</p>
<h3 id="jdk7-ConcurrentHashMap"><a href="#jdk7-ConcurrentHashMap" class="headerlink" title="jdk7 ConcurrentHashMap"></a>jdk7 ConcurrentHashMap</h3><p>1.7时用的分段锁，Segment[]的数组元素是一个数组加链表的结构。</p>
<h4 id="ConcurrentHashMap-put操作"><a href="#ConcurrentHashMap-put操作" class="headerlink" title="ConcurrentHashMap put操作"></a>ConcurrentHashMap put操作</h4><p>先通过key找到承载的Segment对象位置，然后竞争操作Segment的独占锁，以确保操作线程。获取锁tryLock()，如果获取锁失败，执行<code>scanAndLockForPut</code>方法，循环调用<code>tryLock</code>，如果循环次数大于设定好的值（单核为1多核64）执行<code>lock</code>方法，阻塞等待直到获得segment独占锁。</p>
<h4 id="ConcurrentHashMap-get操作"><a href="#ConcurrentHashMap-get操作" class="headerlink" title="ConcurrentHashMap get操作"></a>ConcurrentHashMap get操作</h4><p>计算key的hash值确定segment位置，用<code>UNSAFE.getObjectVolatile</code>获得数据链表，迭代查找对应的value值，并没有获取锁。<br>讨论线程安全问题：</p>
<ol>
<li>一个线程get，一个put<br>先执行get，遍历已经到链表中间，而规定头插法所以不会影响线程安全。如果先执行put，就必须保证刚刚插入的表头节点能被读取，ConcurrentHashMap使用的<code>UNSAFE.putOrderedObject</code>赋值方式保证。</li>
<li>一个put并在扩容，另一个get<br>扩容时新创建HashEntry数组，先执行get则在旧数组上查询，不影响扩容，先执行put的话在oldTable使用了<code>volatile</code>关键字修饰所以不慌。</li>
<li>一个remove，一个get<br>分2种情况， <em>1)</em> 删除节点在链表表头。那操作节点就是HashEntry数组元素了，虽然HashEntry[] table 使用了volatile修饰， 但是， volatile并保证数据内部元素的操作可见性，所以只能使用UNSAFE 来操作元素。 <em>2)</em> 删除节点中标中间，节点中的next属性是volatile修饰所以也不慌。</li>
</ol>
<h3 id="jdk8-ConcurrentHashMap"><a href="#jdk8-ConcurrentHashMap" class="headerlink" title="jdk8 ConcurrentHashMap"></a>jdk8 ConcurrentHashMap</h3><p>抛弃分段锁，采用了较为轻捷的Node + CAS + Synchronized设计，保证线程安全。</p>
<h4 id="put操作"><a href="#put操作" class="headerlink" title="put操作"></a>put操作</h4><p>死循环保证并发时安全添加成功。</p>
<ul>
<li>第一次添加时初始化table数组，</li>
<li>如果数组对应下标不存在节点，用<code>casTabAt</code> : 底层使用<code>Unsafe.compareAndSwapObject</code>原子操作table[i]位置，如果为null，则添加新建的node节点，跳出循环，反之，再循环进入执行添加操作</li>
<li>否则在链表或者红黑树中追加节点<ul>
<li>首先用synchronized对node对象加锁保证线程安全<ul>
<li>判断是链表还是红黑树，分别进入put逻辑</li>
<li>判断是否需要转化成红黑树（树化时也用了synchronized加锁）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="get操作"><a href="#get操作" class="headerlink" title="get操作"></a>get操作</h4><p>和1.7大同小异，获取table[i]存储的节点元素使用了tabAt方法，底层调用了<code>getObjectVolatile()</code>方法保证多线程可见性，获取到内存中最新的元素。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.jianshu.com/p/1e1a96075256" target="_blank" rel="noopener">关于ConcurrentHashMap的分析</a></li>
<li><a href="https://my.oschina.net/u/566591/blog/1549908" target="_blank" rel="noopener">关于几个容器类的比较</a></li>
</ul>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Map</tag>
        <tag>HashMap</tag>
        <tag>TreeMap</tag>
        <tag>LinkedHashMap</tag>
        <tag>ConcurrentHashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap源码分析</title>
    <url>/2020/04/09/HashMap/</url>
    <content><![CDATA[<p>java.util.HashMap继承了AbstractMap类，实现Map接口。<br>用得很多，看看源码记一记。</p>
<p><strong>存储结构：数组+链表</strong>（拉链法解决哈希碰撞）java8加入<strong>红黑树</strong>防止链表长度过大的时候查询效率变慢。</p>
<a id="more"></a>
<ul>
<li>解决hash碰撞的方法：1. <em>开放定址法</em>：向前找空位置存（冲突聚集，删除只能做删除标记，空间满还需要溢出表）； 2. <em>再哈希</em>：再用一个哈希函数（增加计算时间）；3. <em>溢出表</em>：建立公共缓存区，冲突都丢到那里去（缓存区里查询效率变慢）；4. <em>拉链法</em>。</li>
<li>当put新元素使得当前链表长度达到阈值<code>TREEIFY_THRESHOLD</code> 8的时候调用treeify()树化，当remove或resize使得当前链表长度小于等于<code>UNTREEIFY_THRESHOLD</code>6时退化为链表。两个阈值岔开一些防止在阈值附近来回横跳影响性能。</li>
<li>阈值为8的设定： 理想情况下，当加载因子为0.75时，散列表中每个链表的长度k满足期望约为0.5的泊松分布，概率<code>(exp(-0.5) * pow(0.5, k) / factorial(k))</code>计算得出当k取8时到了0.00000006，再长的概率小于百万分之一，所以取8作为树化的阈值。(源码的注释里还贴了英文维基)</li>
<li>数组初始容量16，负载因子0.75，所以扩容的阈值是12。</li>
</ul>
<p>数组定义为<code>transient Node&lt;K,V&gt;[] table;</code>用transient关键字防止序列化是因为HashMap使用的<code>Object.hashCode()</code>方法是native方法，在不同的java虚拟机中可能有不同的实现，序列化之后HashMap失去了跨平台的特性。</p>
<ul>
<li>静态内部类Node中主要有四个成员hash, key, value, next。</li>
</ul>
<p>HashMap不会在构造方法中初始化数组，而是修改threshold为capacity，到第一次put元素时调用扩容<code>resize()</code>方法。</p>
<ul>
<li>用<code>initialCapacity</code>做入参时，调用<code>tableSizeFor()</code>方法求出大于等于<code>intialCapacity</code>的最大的2的幂。 </li>
<li><code>tableSizeFor()</code>算法很有意思，<code>n = cap - 1</code>，然后连续做或运算，分别或上自己的无符号右移1，2，4，8，16次，这样使得n最高位以下都是1，最后加一即为所求2的幂。</li>
</ul>
<p>为什么HashMap的容量都是2的幂次？这和hash计算方法和计算数组下标index有关。</p>
<ul>
<li>hash方法：如果<code>key == null</code> 则返回0，否则计算key的hashCode()，保留高16位不变，低16位异或高16位。这样是防止数组容量较小时能够考虑到高位的不同，减少hash碰撞次数。</li>
<li>计算数组下标index用的是 <code>(n - 1) &amp; hash</code>而非取余运算，因为当容量都是2的幂次时对长度取余和上面的或运算两者是等价的，提高计算效率。</li>
<li>还有一个好处是，扩容的时候节省了一些重新算节点的hash值时间，与运算左边多看一位就行，并且可以把原先的节点分到旧位置和旧位置+oldCap两个下标上面。</li>
</ul>
<h3 id="resize-扩容方法"><a href="#resize-扩容方法" class="headerlink" title="resize() 扩容方法"></a>resize() 扩容方法</h3><p>不仅实现扩容，还负责数组的初始化。</p>
<ul>
<li>过程</li>
</ul>
<ol>
<li>如果<code>oldCap &gt; 0</code>，将数组大小扩大两倍，阀值同样扩大两倍</li>
<li>如果<code>oldCap == 0 &amp;&amp; oldThr &gt; 0</code>，比如调用了规定容量大小的构造函数。将容量设为阀值大小。</li>
<li>如果<code>oldCap ==0</code>代表初始化操作，数组大小为16，阀值为12。</li>
<li>如果<code>oldTab != null</code>代表是扩容操作，对节点重新定位，一个节点 Node 的 hash 字段指的是 key 的 hash，在确定它在数组中的位置是在putVal方法中，采用的是<code>hash &amp; (capacity-1)</code>，capacity能取什么值？2的指数倍，那么在重新安排新位置时先遍历数组，针对每个bin，将里面的节点按照<code>hash &amp; (capacity - 1)</code>分为两拨，如果hash &amp; capacity == 0放在旧位置处，否则放在oldCap + 旧位置 = 新位置处。</li>
</ol>
<ul>
<li>java1.7时候扩容用的头插法，链表扩容之后里面的节点会首尾调换顺序，并发情况下可能会出现死循环问题。java8调整为尾插法，扩容后节点顺序保持原先的先后顺序。</li>
</ul>
<h3 id="put-方法"><a href="#put-方法" class="headerlink" title="put() 方法"></a>put() 方法</h3><p>调用了内部的putVal。</p>
<ul>
<li>过程：</li>
</ul>
<ol>
<li>判断数组是否为空或者长度为0 <ul>
<li>是则调用扩容方法初始化</li>
</ul>
</li>
<li>根据<code>hash &amp; (n - 1)</code>计算所在索引。</li>
<li>talbe[i]是否为空<ul>
<li>是则直接插入</li>
<li>否则比较节点的hash值和key值<ul>
<li>相同则直接覆盖（因为<code>onlyIfAbsent</code>的传入参数是false）</li>
<li>不相同则判断是否是TreeNode节点，是就调用<code>putTreeVal()</code>否则遍历链表插入，并判断这次插入是否使得长度达到树化阈值，是则树化。</li>
</ul>
</li>
</ul>
</li>
<li>++size</li>
<li>判断size是否大于threshold，是则扩容。</li>
</ol>
<h3 id="remove-方法"><a href="#remove-方法" class="headerlink" title="remove()方法"></a>remove()方法</h3><p>调用内部的removeNode()。</p>
<ul>
<li>过程</li>
</ul>
<ol>
<li>前置条件：数组初始化且数组中hash对应下标的节点存在。</li>
<li>判断数组中存的是否就是需要删的<ul>
<li>是则用局部变量node暂存</li>
<li>否则在链表或者红黑树里，判断是否是TreeNode节点，是就调用<code>getTreeNode()</code>找结点，否则遍历链表，比较节点的hash值和key值。</li>
</ul>
</li>
<li>局部变量node不为null，并且value值相同则直接移除node指向的节点。<ul>
<li>如果是TreeNode结点调用<code>removeTreeNode()</code>，</li>
<li>否则如果就是数组里存的节点 <code>tab[index] = node.next;</code></li>
<li>否则 <code>p.next = node.next;</code></li>
</ul>
</li>
</ol>
<h3 id="迭代器的实现"><a href="#迭代器的实现" class="headerlink" title="迭代器的实现"></a>迭代器的实现</h3><p>三个迭代器方法 <code>keySet()</code>, <code>entrySet()</code>，<code>values()</code>返回的是内部成员变量。以entrySet()为例返回的是entrySet成员变量，并没有在添加删除的时候同步维护，而是调用entrySet()的时候创建了一个EntrySet对象。</p>
<p>EntrySet继承了AbstractSet，遍历采用迭代器模式，调用了EntryIterator迭代器类继承<code>HashIterator</code>的<code>nextNode()</code>方法。</p>
<ul>
<li>遍历过程：</li>
</ul>
<ol>
<li>初始化：扫描table数组找到第一个有效的节点并赋值给next对象</li>
<li>遍历：<ul>
<li>next赋值给临时变量e（保证遍历的可持续性，返回的是next，在返回前要找到下一个）</li>
<li>重新设置next对象<ul>
<li>e.next存在表示哈希碰撞了，next指向下一个节点</li>
<li>e.next对象为空或者到达链表尾部了就找下一个index有效的节点。</li>
</ul>
</li>
</ul>
</li>
</ol>
<ul>
<li>HashIterator构造方法中用modCount赋值了<code>expectedModCount</code>，调用<code>nextNode()</code>方法`中判断了这两个Count是否还相等，不相等就抛出并发修改异常。</li>
</ul>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Map</tag>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>美团一面</title>
    <url>/2020/04/08/InterviewExp-meituan/</url>
    <content><![CDATA[<p>4.8 25分钟，基本凉了。</p>
<ul>
<li>自我介绍 </li>
<li>掰扯一下实验室项目 问这个的应用场景 </li>
<li>为什么在实验室项目里用的sqlite不用MySQL </li>
<li>（看出我是自学的）讲一下自己玩的这个项目 </li>
<li>MySQL知道哪些？讲一下并发问题，事务的隔离级别 </li>
<li>MySQL怎么解决幻读问题？(nextKey Lock) </li>
<li>具体讲一下next key Lock？ </li>
<li>索引和间隙锁的关系 </li>
<li>id自增的情况下如何插入一条数据记录？结合实际说明</li>
<li>你对MVCC的理解？（没了解过） </li>
<li>多线程线程池的构造参数 </li>
<li>线程池的源码看过吗 </li>
<li>hashMap源码？怎么计算hashcode？为什么容量是2的幂次方 </li>
<li>常用的集合类？ </li>
<li>TreeMap和HashMap哪个的插入效率高？(emmm还答错了) </li>
</ul>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>java设计模式1 - 创建型模式</title>
    <url>/2020/03/25/DesignPattern1/</url>
    <content><![CDATA[<p>设计模式是一套经过代码编写人员反复试验和总结错误后形成的解决方案，使用设计模式提高了代码的可重用性，更容易被其他程序员所理解。每种模式都针对现实中不同的问题提供了自己的解决方法。Gang of Four提出的主要是面向对象的设计模式规则：面向接口编程而不是面向实现编程，多用对象组合而非继承。</p>
<p>常用的设计模式可分为三大类：创建型模式Creational Pattern，结构型模式Structural Pattern和行为型模式Behavioral Pattern。</p>
<h2 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h2><p>创建型模式主要关注如何创建对象，它们想达到的目标是对象的创建与使用相分离，这样使用者就不需要关注这个对象的实例化过程中的细节，降低系统的耦合度。</p>
<p>主要有单例模式，原型模式，工厂模式，抽象工厂模式，建造者模式。</p>
<a id="more"></a>

<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>单例模式要求该类只允许生成一个实例对象，并且这个对象是由类自行生成，外部通过固定的方法访问这个实例。这个类也叫作单例类。</p>
<p>由于只能生成一个实例对象，单例类的构造方法要被修饰为私有，同时提供静态访问方法供外部访问。</p>
<p><strong>优点：</strong> 内存中只有一个实例减小开销；防止对资源的多重操作。<br><strong>缺点：</strong> 单例类同时要注重类的实现和类的创建，违背了高内聚的单一职责原则。<br><strong>注意事项：</strong> 单例类的静态访问方法在多线程条件下需要加同步锁，防止多个线程同时进入进行多次实例化。</p>
<h3 id="单例模式的多种实现方式"><a href="#单例模式的多种实现方式" class="headerlink" title="单例模式的多种实现方式"></a>单例模式的多种实现方式</h3><h4 id="非线程安全的懒汉式"><a href="#非线程安全的懒汉式" class="headerlink" title="非线程安全的懒汉式"></a>非线程安全的懒汉式</h4><p>在单例类中声明一个静态单例对象<code>Instance</code>，并在静态访问方法<code>getInstance()</code>中完成单例对象的创建。满足了延迟加载(lazy loading)的条件，但由于没有给访问方法加同步锁，所以它线程不安全。</p>
<h4 id="线程安全的懒汉式"><a href="#线程安全的懒汉式" class="headerlink" title="线程安全的懒汉式"></a>线程安全的懒汉式</h4><p>在上一种实现方式的基础上，给静态访问方法加上同步锁，使得其线程安全。它也满足延迟加载的条件，在调用访问方法时才完成单例创建，节省内存，但加锁会影响效率。</p>
<h4 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h4><p>在定义静态单例对象时直接完成创建 <code>private static Singleton Instance = new Singleton()</code>。这种方法在类加载的时候就创建了单例对象，基于classloader机制避免了多线程同步问题，是线程安全的。但如果一直没有外部类访问就浪费了内存，不是延迟加载。</p>
<h4 id="DCL双重校验锁"><a href="#DCL双重校验锁" class="headerlink" title="DCL双重校验锁"></a>DCL双重校验锁</h4><p>给静态单例加上<code>volatile</code>关键字，防止指令重排和保证可见性，然后在静态访问方法中两步校验，通过加锁保证只有一个线程能够进行第二次null值判断，防止多线程情况下创建出多个实例。延迟加载并且线程安全。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;  </span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;  </span><br><span class="line">            singleton = <span class="keyword">new</span> Singleton();  </span><br><span class="line">        &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> singleton;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4><p>将单例对象的声明放置到静态内部类之中。延迟加载并且线程安全。静态内部类不会在<code>Singleton</code>类加载时就加载，而是在调用<code>getInstance()</code>方法时才进行加载，达到了懒加载的效果。</p>
<h4 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h4><p>由于存在反射攻击和反序列化攻击，反射攻击可以通过反射方法获取所有构造器方法，反序列化攻击使用反序列化方法，而创造了多个单例。将单例类定义成枚举，是effective java中推荐的单例模式实现。</p>
<h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><p>用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型相同或相似的新对象。在JAVA中抽象原型类实现clonable接口，具体原型类实现抽象原型类的clone方法，外部类通过调用具体原型类的clone方法获取复制的对象。</p>
<p>适用于对象的创建较为麻烦而复制比较简单的场景。原型模式常常和工厂模式一起出现，用工厂方法把clone()出来的新对象提供给外部调用者。</p>
<p><strong>注意事项：</strong> 与通过对一个类进行实例化来构造新对象不同的是，原型模式是通过拷贝一个现有对象生成新对象的。浅拷贝是实现 Cloneable进行重写，深拷贝是通过实现 Serializable 读取二进制流。</p>
<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>工厂模式又有从简单工厂模式，工厂方法模式到抽象工厂模式的演化，其中后两种是在GOF提出的设计模式之内。</p>
<h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><p>将new对象实例的工作写成一个工厂类，向外部提供一个创建对象的方法，让工厂类通过参数自行实例化特定产品对象。</p>
<p>比如用<code>Shape</code>接口定义几何形状，其中声明了<code>draw</code>方法。圆，正方形等不同的几何形状实现了<code>Shape</code>接口。定义工厂类<code>ShapeFactory</code>，通过传入的参数<code>String shapeType</code>判断具体要实例化哪一个类。</p>
<p><strong>优点：</strong> 屏蔽了类的具体实现，使用者只需知道对象的名称即可得到实例，实现了解耦；<br><strong>缺点：</strong> 如果有新的类加入则需要修改工厂类添加判断，违背了对扩展开放，对修改关闭的开闭原则。</p>
<p>简单工厂模式不属于GOF定义的23中设计模式之中。</p>
<h3 id="工厂方法模式（多态工厂模式）Factory-Method-Pattern"><a href="#工厂方法模式（多态工厂模式）Factory-Method-Pattern" class="headerlink" title="工厂方法模式（多态工厂模式）Factory Method Pattern"></a>工厂方法模式（多态工厂模式）Factory Method Pattern</h3><p>在简单工厂模式的基础上，把工厂类进一步抽象，形成抽象工厂和具体工厂，一类具体工厂创建一类产品对象。将产品类的创建延迟到具体工厂（工厂类的子类）中完成。</p>
<p><strong>优点：</strong> 符合开闭原则，工厂类对扩展开放，对接口关闭；符合单一职责原则，每个具体工厂类只负责创建自己的具体产品对象。<br><strong>缺点：</strong> 如果有新的类加入则需要新建一个对应的具体工厂类，系统的复杂性成对增加。</p>
<h3 id="抽象工厂模式Abstract-Factory-Pattern"><a href="#抽象工厂模式Abstract-Factory-Pattern" class="headerlink" title="抽象工厂模式Abstract Factory Pattern"></a>抽象工厂模式Abstract Factory Pattern</h3><p>为了解决工厂方法中每个具体工厂类只能创建对应的具体产品类，抽象工厂模式提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</p>
<p>多个抽象产品类，每个抽象产品类可以派生出多个具体产品类。一个抽象工厂类，可以派生出多个具体工厂类。 每个具体工厂类可以创建多个具体产品类的实例。  </p>
<p>提出了一个抽象产品族的概念，是抽象产品的父类，描述抽象产品的公共接口。比如手机-手机品牌（三星，苹果，华为）-品牌型号的关系，就分别对应抽象产品族，抽象产品，具体产品。</p>
<p><strong>优点：</strong> 当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。<br><strong>缺点：</strong> 产品族扩展非常困难，要增加一个系列的某一产品，既要在抽象的 Creator 里加代码，又要在具体的里面加代码。<br><strong>使用场景：</strong> 1、QQ 换皮肤，一整套一起换。 2、生成不同操作系统的程序。</p>
<p>注意事项：产品族难扩展，产品等级易扩展。</p>
<h3 id="建造者模式Builder-Pattern"><a href="#建造者模式Builder-Pattern" class="headerlink" title="建造者模式Builder Pattern"></a>建造者模式Builder Pattern</h3><p>使用多个简单的对象一步一步构建成一个复杂的对象，将复杂对象的变与不变分离开。对用户隐藏建造细节，使得用户在不知对象的建造过程 &amp; 细节的情况下，就可直接创建复杂的对象(比如KFC里的套餐，由汉堡薯条小菜饮料各个简单对象组合而成)。</p>
<p><strong>优点：</strong> 1、建造者独立，易扩展。 2、便于控制细节风险。<br><strong>缺点：</strong> 1、产品必须有共同点，范围有限制。 2、如内部变化复杂，会有很多的建造类。<br><strong>使用场景：</strong> 1、需要生成的对象具有复杂的内部结构。 2、需要生成的对象内部属性本身相互依赖。  </p>
<p>与工厂模式相比，建造者模式更关注建造类中各个简单对象的组合关系，工厂模式更关注给外部类提供的工厂方法。</p>
]]></content>
      <categories>
        <category>java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>设计模式</tag>
        <tag>创建型模式</tag>
      </tags>
  </entry>
  <entry>
    <title>mybatis-generator出现ClassNotFoundException的解决方法</title>
    <url>/2020/03/13/mybatis-generator_problems/</url>
    <content><![CDATA[<h2 id="mybatis-generator"><a href="#mybatis-generator" class="headerlink" title="mybatis-generator"></a>mybatis-generator</h2><p>mybatis-generator能够帮我们根据数据库中的表快捷方便地创建Dao，entry，XML，加快开发速度。但是在generate时出现<code>java.lang.ClassNotFoundException: com.mysql.jdbc.Driver</code>错误。</p>
<p>检查了一下连接池参数没有写错。</p>
<p>搜索引擎中说出现这种错误的原因是: 项目中没有导入这个jar包, 或者导入路径错误。</p>
<p>解决方法：在项目目录下src/main/webapp/WEB-INF路径新建lib文件夹，然后把使用的jdbc驱动（如<code>mysql-connector-java-5.1.6.jar</code>）放进去，最后在mybatis-generator的配置文件里给ClassPathEntry字段配置上这个相对路径</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">classPathEntry</span> <span class="attr">location</span>=<span class="string">"src/main/webapp/WEB-INF/lib/mysql-connector-java-5.1.6.jar"</span>/&gt;</span></span><br></pre></td></tr></table></figure>


<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/hejjon/p/10987070.html" target="_blank" rel="noopener">搜到并有效的解决方法</a></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>maven</tag>
        <tag>mybatis</tag>
        <tag>mybatis-generator</tag>
      </tags>
  </entry>
  <entry>
    <title>SSM整合</title>
    <url>/2020/03/11/SSM00/</url>
    <content><![CDATA[<h2 id="SSM整合环境实例"><a href="#SSM整合环境实例" class="headerlink" title="SSM整合环境实例"></a>SSM整合环境实例</h2><p>主要目标：学习SSM整合的过程。用spring去整合springMVC, MyBatis。<br>需求：前台发送请求查询MySQL数据库中的账户信息，数据库表中属性包括id, name, money。<br>基于XML + 注解的方式</p>
<a id="more"></a>

<h2 id="搭建spring框架环境"><a href="#搭建spring框架环境" class="headerlink" title="搭建spring框架环境"></a>搭建spring框架环境</h2><ol>
<li>新建工程，导入依赖包（一大堆）。</li>
<li>完善文件结构：建java文件夹和resources文件夹。</li>
<li>在java源文件夹中，新建domain, service, dao和controller包。<br>在domain包里实现<code>Account</code>类；<br>在service里声明<code>AccountService</code>接口并实现<code>AccountServiceImpl</code>实现类，实现业务层的<code>findAll()</code>和<code>saveAccount()</code>方法（业务层）。</li>
<li>在dao里声明<code>AccountDao</code>接口，也声明这两个方法（持久层）。</li>
<li>新建spring配置文件 <code>applicationContext.xml</code> 开启注解扫描，但只希望处理service和dao，把controller注解留给springmvc。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"hon.example"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置哪些注解不扫描--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:exclude-filter</span> <span class="attr">type</span>=<span class="string">"annotation"</span> <span class="attr">expression</span>=<span class="string">"org.springframework.stereotype.Controller"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ol start="6">
<li>给<code>AccountServiceImpl</code>实现类添加<code>@Service</code>注解</li>
<li>添加test包，为<code>run()</code>方法开启<code>@test</code>注解，实例化AccountService的bean对象，通过执行<code>findAll()</code>方法测试spring框架配置是否成功。</li>
</ol>
<h2 id="搭建springMVC框架的环境"><a href="#搭建springMVC框架的环境" class="headerlink" title="搭建springMVC框架的环境"></a>搭建springMVC框架的环境</h2><p>要求springmvc的框架配置正确，在点击jsp的测试连接能成功跳转。</p>
<ol>
<li><p>写index.jsp： 简单写个测试的超链接就行。</p>
</li>
<li><p>在web.xml中配置前端控制器servlet和servlet-mapping (<code>DispatcherServlet</code>)，使用<code>&lt;init-param&gt;</code>和<code>&lt;load-on-startup&gt;</code>在启动时加载springmvc的配置文件<code>springmvc.xml</code>;<br>同时顺便写上解决中文乱码问题的字符过滤器filter和filter-mapping (CharacterEncodingFilter)</p>
 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 加载springmvc配置文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springmvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">&lt;!--中文乱码过滤器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>characterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>characterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>写springmvc.xml配置文件。</p>
<ul>
<li>注解扫描<code>Controller</code>，让springmvc自动管理Controller bean。<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"hon.example"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">"annotation"</span> <span class="attr">expression</span>=<span class="string">"org.springframework.stereotype.Controller"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>配置视图解析器<code>InternalResourceViewResolver</code><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"internalResourceViewResolver"</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"prefix"</span> <span class="attr">value</span>=<span class="string">"/WEB-INF/pages/"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suffix"</span> <span class="attr">value</span>=<span class="string">".jsp"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>过滤静态资源（还不清楚）<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">"/css/"</span> <span class="attr">location</span>=<span class="string">"/css/**"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">"/images/"</span> <span class="attr">location</span>=<span class="string">"/images/**"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">"/js/"</span> <span class="attr">location</span>=<span class="string">"/js/**"</span>/&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>开启注解支持<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>在Controller中写<code>AccountController</code>类（表现层），开启<code>Controller</code>和<code>RequestMapping</code>注解，与<code>index.jsp</code>中超链接的url对应。<br>实现<code>findAll()</code>方法，返回<code>&quot;list&quot;</code>字符串。</p>
</li>
<li><p>按视图解析器中配置的路径新建<code>list.jsp</code></p>
</li>
<li><p>启动Tomcat服务器，测试是否成功调用<code>AccountController</code>类的<code>findAll()</code>方法实现页面跳转。</p>
</li>
</ol>
<h2 id="Spring整合SpringMVC"><a href="#Spring整合SpringMVC" class="headerlink" title="Spring整合SpringMVC"></a>Spring整合SpringMVC</h2><p><strong>思路：</strong> 在Controller类中的<code>findAll()</code>方法中需要调用业务层的方法，所以需要进行service对象的依赖注入，然而在服务器启动的过程中只加载了springmvc配置文件而没有加载spring的配置文件，无法由spring创建service的IoC容器。<br><strong>解决：</strong> 使用监听器监听ServletContext域对象的创建和销毁，用监听器加载spring的配置文件。</p>
<ol>
<li>在web.xml中配置监听器加载spring的配置文件（注意需要指定contextConfigLocation配置路径）<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置监听器 默认只加载WEB-INF目录下的applicationContext.xml配置文件--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><code>AccountController</code>类中添加成员<code>AccountService</code>，开启<code>@AutoWired</code>注解完成依赖注入。</li>
<li>启动Tomcat服务器，测试是否成功调用<code>AccountController</code>类的<code>findAll()</code>方法实现页面跳转，其中调用业务层方法。</li>
</ol>
<h2 id="搭建MyBatis环境并单独测试"><a href="#搭建MyBatis环境并单独测试" class="headerlink" title="搭建MyBatis环境并单独测试"></a>搭建MyBatis环境并单独测试</h2><p>可以在SQLMapConfig配置文件写SQL语句，也可以直接在接口上加注解（用的是这个）。</p>
<ol>
<li>首先启动MySQL服务，新建ssm数据库，创建account表(可用SQLylog程序)，其中有id, name, money三个字段。 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">account</span>(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">INT</span> PRIMARY <span class="keyword">KEY</span> AUTO_INCREMENT,</span><br><span class="line"><span class="keyword">NAME</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">money <span class="keyword">DOUBLE</span></span><br><span class="line">   );</span><br></pre></td></tr></table></figure></li>
<li>在<code>AccountDao</code>接口的两个方法上分别添加注解。 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查询所有用户</span></span><br><span class="line"><span class="meta">@Select</span>(<span class="string">"select * from account"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Account&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//保存账户信息</span></span><br><span class="line"><span class="meta">@Insert</span>(<span class="string">"insert into account (name, money) values (#&#123;name&#125;, #&#123;money&#125;)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveAccount</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>编写SqlMapConfig.xml配置文件，配置mysql环境连接池参数。 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">"mysql"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">"mysql"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">"JDBC"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"POOLED"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3306/ssm"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"123456"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>配置路径 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引入配置文件或明确注解路径--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;mapper class="hon.example.dao.AccountDao"/&gt; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"hon.example.dao"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>编写测试类<code>testMybatis</code>，分别测试持久层的两个方法。注意，查询不需要提交事务而增删改都需要手动提交事务。 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testMybatis</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//加载配置文件</span></span><br><span class="line">        InputStream inputStream = Resources.getResourceAsStream(<span class="string">"SqlMapConfig.xml"</span>);</span><br><span class="line">        <span class="comment">//创建SqlSessionFactory对象</span></span><br><span class="line">        SqlSessionFactory factory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">        <span class="comment">//创建sqlSession对象</span></span><br><span class="line">        SqlSession session = factory.openSession();</span><br><span class="line">        <span class="comment">//获取代理对象</span></span><br><span class="line">        AccountDao dao = session.getMapper(AccountDao<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        List&lt;Account&gt; list = dao.findAll();</span><br><span class="line">        <span class="keyword">for</span> (Account account :list)&#123;</span><br><span class="line">            System.out.println(account);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        session.close();</span><br><span class="line">        inputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    测试插入方法saveAccount()</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run2</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建Account对象</span></span><br><span class="line">        Account newAccount = <span class="keyword">new</span> Account();</span><br><span class="line">        newAccount.setName(<span class="string">"西西"</span>);</span><br><span class="line">        newAccount.setMoney(<span class="number">5000</span>d);</span><br><span class="line">        <span class="comment">//加载配置文件</span></span><br><span class="line">        InputStream inputStream = Resources.getResourceAsStream(<span class="string">"SqlMapConfig.xml"</span>);</span><br><span class="line">        <span class="comment">//创建SqlSessionFactory对象</span></span><br><span class="line">        SqlSessionFactory factory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">        <span class="comment">//创建sqlSession对象</span></span><br><span class="line">        SqlSession session = factory.openSession();</span><br><span class="line">        <span class="comment">//获取代理对象</span></span><br><span class="line">        AccountDao dao = session.getMapper(AccountDao<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//增！</span></span><br><span class="line">        dao.saveAccount(newAccount);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//提交事务</span></span><br><span class="line">        session.commit();</span><br><span class="line"></span><br><span class="line">        session.close();</span><br><span class="line">        inputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="spring整合MyBatis"><a href="#spring整合MyBatis" class="headerlink" title="spring整合MyBatis"></a>spring整合MyBatis</h2><p>思路： 将DAO的代理对象存入到容器中，然后在service中完成对象注入。</p>
<ol>
<li><p>在spring配置文件中新增配置</p>
<ul>
<li>配置连接池<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"com.mchange.v2.c3p0.ComboPooledDataSource"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClass"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jdbcUrl"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql:///ssm?useUnicode=true<span class="symbol">&amp;amp;</span>characterEncoding=utf-8<span class="symbol">&amp;amp;</span>serverTimezone=GMT%2B8"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"123456"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>配置SqlSessionFactory工厂<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sqlSessionFactory"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.SqlSessionFactoryBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>配置AccountDao接口所在包<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"mapperScannerConfigurer"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.mapper.MapperScannerConfigurer"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"basePackage"</span> <span class="attr">value</span>=<span class="string">"hon.example.dao"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>以上配置完成之后，单独测试Mybatis时所使用的SqlMapConfig.xml其实可以不需要了。</li>
</ul>
</li>
<li><p>给<code>AccountDao</code>接口添加<code>@Repository</code>注解</p>
</li>
<li><p><code>AccountServiceImpl</code>实现类中添加<code>AccountDao</code>对象，开启<code>@AutoWired</code>注解完成依赖注入。改写业务层的两个方法使之分别调用持久层中<code>AccountDao</code>的两个方法。</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceimpl</span> <span class="keyword">implements</span> <span class="title">AccountService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountDao accountDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Account&gt; <span class="title">findAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"业务层： 查询所有账户信息..."</span>);</span><br><span class="line">        <span class="keyword">return</span> accountDao.findAll();</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveAccount</span><span class="params">(Account account)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"业务层：保存账户中..."</span>);</span><br><span class="line">        accountDao.saveAccount(account);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>为了向数据库增删改数据时能够提交事务，需要在spring配置文件中加入声明式事务管理的配置。</p>
<ul>
<li>配置事务管理器<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>事务通知<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">"txAdvice"</span> <span class="attr">transaction-manager</span>=<span class="string">"transactionManager"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"find*"</span> <span class="attr">read-only</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"*"</span> <span class="attr">isolation</span>=<span class="string">"DEFAULT"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>配置AoP增强<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">"txAdvice"</span> <span class="attr">pointcut</span>=<span class="string">"execution(* hon.example.service.impl.*Serviceimpl.*(..))"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>业务层和持久层逻辑已经完成，改写表现层的两个方法。</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/findAll"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">findAll</span><span class="params">(Model model)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"表现层： 查询所有账户"</span>);</span><br><span class="line">    <span class="comment">//调用service的方法</span></span><br><span class="line">    List&lt;Account&gt; list = accountService.findAll();</span><br><span class="line">    model.addAttribute(<span class="string">"list"</span>, list);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"list"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 在save()方法中我们希望完成账户信息的保存后能够重定向到查询页面，可以使用<code>HttpServletResponse</code>和<code>HttpServletRequest</code>获取重定向的路径。</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/save"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(Account account, HttpServletResponse response, HttpServletRequest request)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"表现层： 查询所有账户"</span>);</span><br><span class="line">    <span class="comment">//调用service的方法</span></span><br><span class="line">    accountService.saveAccount(account);</span><br><span class="line">    <span class="comment">//重定向</span></span><br><span class="line">    response.sendRedirect(request.getContextPath()+ <span class="string">"/account/findAll"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>修改index.jsp加入测试新增账户信息的表单。</p>
 <figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;h3&gt;测试保存&lt;/h3&gt;</span><br><span class="line">&lt;form action=<span class="string">"account/save"</span> method=<span class="string">"post"</span>&gt;</span><br><span class="line">    姓名：&lt;input type=<span class="string">"text"</span> name=<span class="string">"name"</span> /&gt;&lt;br/&gt;</span><br><span class="line">    金额：&lt;input type=<span class="string">"text"</span> name=<span class="string">"money"</span>/&gt;&lt;br/&gt;</span><br><span class="line">    &lt;input type=<span class="string">"submit"</span> name=<span class="string">"保存"</span>/&gt;&lt;br/&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure></li>
<li><p><code>list.jsp</code>中要求显示出所有的账户姓名和钱数。可以简单使用 ${list} 也可写jstl表达式。</p>
 <figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">"text/html;charset=UTF-8"</span> language=<span class="string">"java"</span> isELIgnored=<span class="string">"false"</span> %&gt;</span><br><span class="line">&lt;%@ taglib prefix=<span class="string">"c"</span> uri=<span class="string">"http://java.sun.com/jsp/jstl/core"</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">   &lt;body&gt;</span><br><span class="line">     &lt;h2&gt;查询到所有账户&lt;/h2&gt;</span><br><span class="line">        &lt;c:forEach items=<span class="string">"$&#123;list&#125;"</span> <span class="keyword">var</span>=<span class="string">"account"</span>&gt;</span><br><span class="line">          $&#123;account.name&#125;</span><br><span class="line">          $&#123;account.money&#125; &lt;br&gt;</span><br><span class="line">    &lt;/c:forEach&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>完成，开启Tomcat服务器进行测试。  </p>
<ul>
<li>点击测试查询的超链接，发送请求到前端控制器，处理器执行<code>findAll()</code>方法，调用<code>accountService</code>容器的<code>findAll()</code>方法进入业务层，业务层的<code>findAll()</code>方法调用<code>accountDao</code>容器的<code>findAll()</code>方法，从而在数据库中执行查询语句，层层返回，最后有model对象的<code>addAttribute()</code>方法封装到<code>list.jsp</code>页面。  </li>
<li>填写测试保存的表单，点击提交，发送提交请求，处理器执行<code>save()</code>方法，调用<code>accountService</code>容器的<code>saveAccount()</code>方法进入业务层，业务层的<code>saveAccount()</code>方法调用<code>accountDao</code>容器的<code>save()</code>方法，从而在数据库中执行insert语句，并由spring的事务管理器提交事务。之后表现层获取通过原生API重定向路径到findAll方法查询所有数据。</li>
</ul>
</li>
</ol>
<h2 id="Troubleshooting"><a href="#Troubleshooting" class="headerlink" title="Troubleshooting"></a>Troubleshooting</h2><p>在测试MyBatis时抛出了异常</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">org.apache.ibatis.exceptions.PersistenceException: </span><br><span class="line">### Error querying database.  Cause: java.sql.SQLException: The server time zone value &#39;�й���׼ʱ��&#39; is unrecognized or represents more than one time zone. You must configure either the server or JDBC driver (via the serverTimezone configuration property) to use a more specifc time zone value if you want to utilize time zone support.</span><br></pre></td></tr></table></figure>

<p>查了一下，问题是我的MySQL版本过高（装的是8.0.16）造成时区问题（同时还有中文乱码的问题）。解决方法：</p>
<ol>
<li>降低pom.xml中mysql-connector-java的版本如5.1.35（未完全解决）</li>
<li>修改url为，指定字符集和时区：<code>&lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/ssm?useUnicode=true&amp;amp;characterEncoding=utf-8&amp;amp;serverTimezone=GMT%2B8&quot;/&gt;</code></li>
</ol>
<h2 id="Notes"><a href="#Notes" class="headerlink" title="Notes"></a>Notes</h2><ul>
<li><a href="https://github.com/AlenZhon/SSM_demo" target="_blank" rel="noopener">项目工程点这里</a></li>
<li><a href="https://www.bilibili.com/video/av86932976?p=52" target="_blank" rel="noopener">教程看的是这个</a></li>
</ul>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
        <tag>springMVC</tag>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC 相关概念（二）参数绑定&amp;常用注解</title>
    <url>/2020/03/11/SpringMVC_01/</url>
    <content><![CDATA[<h2 id="SpringMVC请求参数的绑定"><a href="#SpringMVC请求参数的绑定" class="headerlink" title="SpringMVC请求参数的绑定"></a>SpringMVC请求参数的绑定</h2><p>浏览器把参数数据封装Request中发送给后台，后台Controller如何知道Request参数对应方法里的哪个参数？<br>常用方法：</p>
<ol>
<li>方法传入参数的名字和Request参数的名字完全一致。</li>
<li>在方法参数处使用<code>@RequestParam</code>绑定请求参数值，其中<code>value</code>/<code>name</code>属性是请求参数名， <code>require</code>表示请求参数是否必须，默认为true，<code>defaultValue</code>表示请求参数的默认值，不存在则抛出异常。</li>
<li>注解<code>@RequestMapping</code>接收参数。注解上的参数必须和请求参数相同。</li>
</ol>
<p>例如，Request发来的参数为一个<code>username</code>，下列方法都可以实现参数绑定</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"/testParam"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testParam</span><span class="params">(String username)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"/testParam"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testParam</span><span class="params">( @RequestParam(value = <span class="string">"username"</span>)</span>String username)</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"/testParam/&#123;username&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testParam</span><span class="params">(@PathVariable(<span class="string">"username"</span>)</span> String name)</span></span><br></pre></td></tr></table></figure>

<p>此外，也可以<br>4. 使用POJO对象将所有请求参数封装到对象中，要求对象中的属性包含所有请求参数且一一对应。<br>5. 使用原生的Servlet API 作为Controller 方法的参数。 如HttpServletRequest, HttpServletResponse</p>
<h3 id="解决表单传参数中文乱码的问题"><a href="#解决表单传参数中文乱码的问题" class="headerlink" title="解决表单传参数中文乱码的问题"></a>解决表单传参数中文乱码的问题</h3><p>在web.xml中配置字符过滤器。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--  配置字符过滤器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>characterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>characterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="自定义数据类型转换器"><a href="#自定义数据类型转换器" class="headerlink" title="自定义数据类型转换器"></a>自定义数据类型转换器</h3><p>MVC框架可以自动转换大部分基本数据类型，但某些自动转换会报错。例如String转Date，如果输入字符串”2020-1-1”则会报BAD REQUEST。</p>
<ol>
<li>首先写一个类型转换类，实现Converter接口。  </li>
<li>然后在xml中配置这个自定义类型转换器。  </li>
<li>最后配置自定义类型转换器生效 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span> <span class="attr">conversion-service</span>=<span class="string">"conversionService"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h2><ol>
<li>@RequestParam 修饰Controller方法参数<br> 参数绑定时已经有过详细介绍。</li>
<li>@RequestBody 修饰方法参数，直接获取请求体的内容。<br> 不适用GET（因为GET请求没有请求体）</li>
<li>@PathVariable 用于绑定url中的占位符，被视为支持RESTful风格。<br> 在参数绑定的第三个方法中使用。</li>
<li>@RequestHeader 修饰方法参数，获取请求头。</li>
<li>@CookieValue 获取指定Cookie的值</li>
<li>@ModelAttribute 出现在方法上，表示当前方法会在Controller方法执行前执行；出现在参数上表示获取指定数据给参数赋值。</li>
<li>@SessionAttribute 用于多次执行Controller方法的数据共享。</li>
</ol>
]]></content>
      <categories>
        <category>java</category>
        <category>springMVC</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>springMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC 相关概念</title>
    <url>/2020/03/10/SpringMVC/</url>
    <content><![CDATA[<p>了解一些SpringMVC的基本概念，并用一个入门程序加深理解。</p>
<h2 id="SpringMVC-入门"><a href="#SpringMVC-入门" class="headerlink" title="SpringMVC 入门"></a>SpringMVC 入门</h2><ol>
<li><p>服务器端的三层框架：表现层，业务层，持久层(SSM中分别对应SpringMVC, Spring, MyBatis)</p>
</li>
<li><p>MVC设计模型： Model模型（多用于封装数据），View视图（多用于展示数据），Controller控制器（处理程序逻辑）。是一种用于设计创建web应用程序表现成的模式</p>
</li>
<li><p>SpringMVC是基于MVC设计模型的轻量级web框架。其他的MVC开发框架有struts, struts2等。共同点：都是基于MVC模型表现层框架，底层离不开原始的ServletAPI，且处理请求的机制都是核心控制器。区别：MVC核心控制器是servlet，struts2基于过滤器。前者基于方法设计，后者基于类，每次执行时都创建一个动作类。struts2的OGNL表达式使开发效率高一些，但是执行效率和JSTL提升不大。</p>
</li>
</ol>
<h2 id="入门程序"><a href="#入门程序" class="headerlink" title="入门程序"></a>入门程序</h2><p>需求：web页面上有一个超链接，点击超链接可处理请求，并跳转到请求成功页面。开发步骤：搭建环境-&gt;代码</p>
<a id="more"></a>

<h3 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h3><ol>
<li>new project 时点选Create from archetype，点选<code>maven-archetype-webapp</code>创建项目。解决Maven加载过慢可添加键值对：archetypeCatalog internal（这个键值对的作用可看参考）。</li>
<li>在main文件夹中目录结构补完： java和resources文件夹。</li>
<li>引入依赖包。可以在<code>properties</code>字段里显式配置<code>spring.version</code>锁定使用版本。</li>
<li><code>web.xml</code>配前端控制器。配置servlet字段<code>DispatcherServlet</code>和servletMapping字段。</li>
<li>使用Tomcat启动服务器部署。之前没有下载tomcat，去下了一个tomcat 8.5.51。然后在run configuration里做相应配置。</li>
<li>Run，自动弹出默认浏览器显示HelloWorld。</li>
</ol>
<h3 id="代码修改"><a href="#代码修改" class="headerlink" title="代码修改"></a>代码修改</h3><ol>
<li><p>index.jsp页面上为防止中文乱码确定字符集为utf-8.在开头添加<code>&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;</code></p>
</li>
<li><p>创建<code>springMVC.xml</code>并开启注解扫描。</p>
</li>
<li><p>在servlet创建时加载springMVC.xml: 新增<code>&lt;init-param&gt;</code>提供全局初始化参数，在<code>&lt;contextConfigLocation&gt;</code>指定springMVC.xml的位置。并添加<code>&lt;load-on-startup&gt;</code>使服务器启动时加载配置文件</p>
 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springMVC.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>创建Controller类<code>HelloController</code>，开启@Controller注解和@RequestMapping注解，指定请求映射参数（与jsp页面的<code>“href”</code>相同).<br> 实现sayHello方法返回”success”字符串则默认跳转到”success.jsp”</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//控制器的类</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(path = <span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello SpringMVC!"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>创建跳转页面<code>success.jsp</code>，放在<code>WEB-INF/pages</code>目录下</p>
</li>
<li><p>在springMVC.xml配置文件中开启视图解析器<code>InternalResourceViewResolver</code>，自动解析页面地址；还开启了一个springMVC的注解支持(作用看后文)</p>
 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 视图解析器对象 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"internalResourceViewResolver"</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"prefix"</span> <span class="attr">value</span>=<span class="string">"WEB-INF/pages/"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suffix"</span> <span class="attr">value</span>=<span class="string">".jsp"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 开启SpringMVC注解支持--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>启动服务器，点击跳转，成功。</p>
</li>
</ol>
<h2 id="入门程序的运行流程分析"><a href="#入门程序的运行流程分析" class="headerlink" title="入门程序的运行流程分析"></a>入门程序的运行流程分析</h2><ol>
<li><p>启动服务器，加载配置文件</p>
<ul>
<li><code>load-on-startup</code>使得启动服务器时创建了<code>servlet</code>对象，同时加载了<code>springMVC.xml</code>配置文件。</li>
<li>由于配置文件中开启了注解扫描，将<code>Controller</code>类加载进IoC容器中生成<code>Singleton</code>对象。视图解析器也被配置成对象。</li>
<li><code>SpringMVC</code>注解支持使得<code>RequestMapping</code>注解生效。</li>
</ul>
</li>
<li><p>发送跳转请求，后台处理请求</p>
<ul>
<li>点击<code>index.jsp</code>上的超链接，<code>DispatcherSerlvet</code>前端控制器拦截请求。</li>
<li>请求查找 <code>HandlerMapping</code> 处理器映射器，处理器映射器返回handle方法</li>
<li>前端控制器请求 <code>HandlerAdapter</code> handler适配器，由handler处理器执行方法，再通过适配器返回ModelAndView（实际上返回视图页面<code>success.jsp</code>），</li>
<li>前端控制器请求视图解析器对象<code>InternalResourceViewResolver</code>，视图解析器返回View视图，再把模型数据填充到Request域。</li>
<li><code>DispatcherSerlvet</code>响应到浏览器。</li>
</ul>
</li>
</ol>
<h2 id="lt-mvc-annotation-driven-gt-的作用？"><a href="#lt-mvc-annotation-driven-gt-的作用？" class="headerlink" title="&lt;mvc:annotation-driven/&gt;的作用？"></a><code>&lt;mvc:annotation-driven/&gt;</code>的作用？</h2><p>处理器映射器，处理器适配器和视图解析器被称为SpringMVC的三大组件。<br>使用<code>&lt;mvc:annotation-driven/&gt;</code>可自动加载处理映射器<code>HandlerMapping</code>和处理适配器<code>HandlerAdapter</code>，简化注解配置</p>
<h2 id="RequestMapping注解"><a href="#RequestMapping注解" class="headerlink" title="RequestMapping注解"></a><code>RequestMapping</code>注解</h2><p><code>RequestMapping</code>注解既可以放在方法上，也可以放在类上。如果类上和方法上都进行<code>RequestMapping</code>注解，path可指定多级目录实现模块化开发。</p>
<p>常用属性：</p>
<ul>
<li><code>value</code> 表示请求的url，和path属性是一样的。（路径错误浏览器返回<code>404 PAGE NOT FOUND</code>）</li>
<li><code>method</code> 指当前方法可以接收什么请求方式（GET, POST），枚举类RequestMethod中定义了请求方式。(不在规定method中浏览器返回<code>405 METHOD NOT ALLOWED</code>)</li>
<li><code>params</code> 限制请求参数的条件。要求请求参数的key和value值和指定的params参数一模一样。(参数不对应浏览器返回<code>400 BAD REQUEST</code>)</li>
<li>headers 指定HTTP的特定请求头必须存在。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.cnblogs.com/taiguyiba/p/11727758.html" target="_blank" rel="noopener">archetypeCatalog=internal键值对的作用</a></li>
<li><a href="https://github.com/AlenZhon/SpringMVC_start" target="_blank" rel="noopener">入门程序详见我的Github</a></li>
</ul>
]]></content>
      <categories>
        <category>java</category>
        <category>springMVC</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>springMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven替换国内镜像</title>
    <url>/2020/03/10/MavenMirrorChange/</url>
    <content><![CDATA[<p>idea中Maven默认下载源的速度慢，每次下载jar包要import很久，所以想更换到国内镜像。</p>
<a id="more"></a>

<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>首先查看一下自己使用的Maven是IDEA自带的还是自己安装的。<br>IDEA –&gt; File –&gt; project settings –&gt; 搜索 Maven –&gt; 看Maven home directory那一栏。 发现我的显示是<code>Bundled (Maven 3)</code></p>
<p>win7环境，默认情况下在用户目录的.m2下自己新建setting文件。到User Setting File一栏的地址去打开<code>setting.xml</code>。修改为如下所示修改到阿里云镜像：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/SETTINGS/1.0.0"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/SETTINGS/1.0.0</span></span></span><br><span class="line"><span class="tag"><span class="string">                          https://maven.apache.org/xsd/settings-1.0.0.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrors</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果Maven home directory那一栏显示的是自定义的Maven安装路径，则打开Maven安装目录下<code>conf/settings.xml</code>。查找Mirror字段，修改为：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.cnblogs.com/draculaqk/p/7613807.html" target="_blank" rel="noopener">修改Intelij IDEA的maven依据下载为国内镜像（阿里）</a></li>
<li><a href="http://www.luyixian.cn/news_show_259457.aspx" target="_blank" rel="noopener">maven换源</a></li>
</ul>
]]></content>
      <categories>
        <category>java</category>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Overview</title>
    <url>/2020/03/10/Spring00/</url>
    <content><![CDATA[<p>了解一些Spring框架的相关概念并做简单记录。</p>
<h2 id="整体"><a href="#整体" class="headerlink" title="整体"></a>整体</h2><ol>
<li>Spring 开源框架，三个特性：IoC Inversion of Control控制反转，程序员对对象的创建和控制交由Spring容器，DL依赖注入（依赖注入是IoC的实现方式）， AoP面向切片编程。</li>
<li>模块化，大约有20个模块。核心容器(<code>Core Container</code>)由<code>spring-core，spring-beans，spring-context，spring-context-support</code>和<code>spEL</code>组成，数据访问/集成层包括 <code>JDBC，ORM，OXM，JMS</code> 和事务处理模块，Web 层由 <code>Web，Web-MVC，Web-Socket</code> 和 <code>Web-Portlet</code> 组成，还有其他一些重要的模块，像 <code>AOP，Aspects，Instrumentation</code> 和测试模块。</li>
</ol>
<a id="more"></a>

<h2 id="Spring-bean"><a href="#Spring-bean" class="headerlink" title="Spring bean"></a>Spring bean</h2><ol start="3">
<li><code>Application Context</code> 是 <code>BeanFactory</code> 的子接口，也被称为 Spring 上下文。</li>
<li>bean 是一个被实例化，组装，并通过 Spring IoC 容器所管理的对象。SpringIoC容器可通过三种方式配置bean：<strong>基于XML配置文件，基于注解，基于Java配置</strong>。下面基于XML进行Bean参数(<code>id, class, scope, init-method, destroy-method</code>)的说明。</li>
<li>创建bean的三种方式：使用构造器创建，使用静态工厂创建，使用实例工厂创建。</li>
<li>Spring 框架支持以下五个bean作用域(scope = )，分别为<code>singleton(默认)、prototype、request、session和global session</code>。如果每次调用<code>getBean</code>都是获取同一个实例则需要声明作用域为<code>singleton</code>，如果每次调用都<code>new</code>一个实例则声明为<code>prototype</code>。使用 web-aware ApplicationContext时，<code>request</code>表示每次HTTP请求都new一个实例，<code>session</code>表示同一个session共享同个实例，<code>global session</code>一般用于Portlet应用环境。</li>
<li>Bean可由<code>init-method</code>和<code>destroy-method</code>参数定义初始化回调方法和销毁回调方法。如果许多Bean中的初始化方法和销毁方法相同，可以直接写到beans的配置中，利用<code>default-init-method</code> 和 <code>default-destroy-method</code>属性完成初始化和销毁方法的声明。</li>
<li>Bean的继承：子 bean继承了父定义的配置数据，通过parent参数进行声明。Bean的继承与java的继承无关，不需要对应的两个java类用extend关键字继承，但需要子类要继承的属性和父类相同。</li>
<li>可定义Bean模板，使得其他Bean的定义从模板继承。模板不声明class属性而是声明<code>abstract=”true”</code>。</li>
</ol>
<h2 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h2><ol start="10">
<li>依赖注入：依赖类不由程序员实例化，而是通过spring容器帮我们new指定实例并且将实例注入到需要该对象的类。常用有：<strong>构造方法注入，set方法参数注入，基于注解@Autowired注入</strong>。</li>
<li><strong>构造方法注入</strong>；当容器调用带有一组参数的类构造函数时，基于构造函数的 DI 就完成了，其中每个参数代表一个对其他类的依赖。XML配置文件中使用<code>constructor-arg</code>。如果构造函数参数有多个，则要在配置文件中按顺序给出/在后面添加<code>index</code>标签显式指定参数索引值。<code>ref</code>传递引用（依赖类），<code>value</code>传递值（基本数据类型或成员属性）。</li>
<li><strong>Setter注入</strong>：当容器调用无参构造函数时，通过容器调用setter函数完成依赖注入。XML配置文件中使用<code>property</code>标签。</li>
<li><strong>@Autowired注入</strong>：Bean类依赖注入对象的setter函数或构造函数前加上<code>@Autowired</code>。默认情况下<code>@Autowired</code>是按类型匹配的(byType)。XML配置文件中要添加一行<code>&lt;context:annotation-config/&gt;</code>。</li>
<li><code>&lt;context:annotation-config/&gt;</code>：仅能够在已经在已经注册过的bean上面起作用。对于没有在spring容器中注册的bean，它并不能执行任何操作。<br><code>&lt;context:component-scan base-package=&quot;XX.XX&quot;/&gt;</code> ：除了具有上面的功能之外，还具有自动将带有<code>@component, @service, @Repository</code>等注解的对象注册到spring容器中的功能。</li>
<li><strong>@Required</strong> 注解应用于 bean 属性的 setter 方法，它表明受影响的 bean 属性在配置时必须放在 XML文件中，否则容器就会抛出<code>BeanInitializationException</code> 异常。</li>
<li>当使用<code>@Autowired</code> 标注setter方法时，默认采用byType自动装配策略。在这种策略下，符合自动装配类型的候选Bean实例常常有多个，这个时候就可能引起异常，为了实现精确的自动装配，Spring提供了 <strong>@Qualifier</strong> 注解，通过使用<code>@Qualifier</code>，允许根据Bean的id来执行自动装配</li>
<li>inner beans 是在其他 bean 的范围内定义的 bean。类似Java内部类的概念。</li>
<li>注入集合对象：使用<code>&lt;list&gt; &lt;set&gt; &lt;map&gt; &lt;props&gt;</code>分别表示<code>list, set, map, properties</code>其中<code>properties</code>要求<code>key</code>和<code>value</code>都是字符串类型而<code>map</code>不要求类型。</li>
</ol>
<h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><ol start="19">
<li><strong>事件处理</strong>：Spring提供<code>ApplicationListener</code> 接口实现事件管理。一个实现这个接口的事件类应实现一个<code>onApplicationEvent</code>方法。Main方法中<code>context</code>为<code>ConfigurableApplicationContext</code>的实例。Spring 的事件处理是单线程的，所以如果一个事件被发布，直至并且除非所有的接收者得到的该消息，该进程被阻塞并且流程将不会继续。</li>
<li><strong>自定义事件处理</strong>：继承<code>ApplicationEvent</code>类，同时必须定义默认构造函数。</li>
</ol>
<h2 id="AoP"><a href="#AoP" class="headerlink" title="AoP"></a>AoP</h2><ol start="21">
<li>Spring框架的AOP机制可以让开发者把业务流程中的通用功能抽取出来，单独编写功能代码。在业务流程执行过程中，Spring框架会根据业务流程要求，自动把独立编写的功能代码切入到流程的合适位置。</li>
<li><strong>切面（<code>Aspect</code>）</strong>：一个关注点的模块化，这个关注点可能会横切多个对象。事务管理是J2EE应用中一个关于横切关注点的很好的例子。<strong>连接点（<code>JointPoint</code>）</strong>表示业务流程在运行过程中需要插入切面的具体位置（方法）。<strong>通知（<code>Advice</code>）</strong>：在切面的某个特定的连接点上执行的动作。<strong>切点（<code>Pointcut</code>）</strong>：用于定义通知应该切入到哪些连接点上，不同的通知通常需要切入到不同的连接点上。<strong>目标对象（<code>Target</code>）</strong>：被一个或者多个切面所通知的对象。<strong>代理（<code>Proxy</code>）</strong>：目标对象的业务逻辑功能加上被切入的切面所形成的对象。<strong>织入（<code>Weaving</code>）</strong>：把切面连接到其它的应用程序类型或者对象上，并创建一个被通知的对象。这个过程可以发生在编译期、类装载期及运行期。</li>
<li>通知类型：<code>Before Advice/After Returning/After throwing/After (finally)/Around advice</code></li>
<li>在Spring AOP中，切面可以使用基于XML配置或者基于<code>@Aspect</code>注解的方式来实现。 需要在 pom.xml 里导入依赖包<code>aspectjrt</code>和 <code>aspectjweaver</code>。</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>中文资料感觉都不新。</p>
<ul>
<li><a href="https://www.docs4dev.com/docs/zh/spring-framework/4.3.21.RELEASE/reference/overview-getting-started-with-spring.html#spring-%E5%85%A5%E9%97%A8" target="_blank" rel="noopener">Spring Framework中文文档(机翻味道浓，有时间建议看英文)</a></li>
<li><a href="https://www.w3cschool.cn/wkspring/pesy1icl.html" target="_blank" rel="noopener">w3cschool的spring教程</a></li>
<li><a href="https://wiki.jikexueyuan.com/project/spring/" target="_blank" rel="noopener">极客学院的spring教程</a></li>
</ul>
]]></content>
      <categories>
        <category>java</category>
        <category>spring</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/03/08/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<a id="more"></a>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
      <categories>
        <category>helloworld</category>
      </categories>
      <tags>
        <tag>helloworld</tag>
      </tags>
  </entry>
  <entry>
    <title>利用Hexo在github上搭建静态个人博客</title>
    <url>/2020/03/08/hexo/</url>
    <content><![CDATA[<h1 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h1><p><a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo</a> 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。<br>需要先安装Git和nodeJS。</p>
<a id="more"></a>


<h1 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h1><ol>
<li><p>首先去下载<a href="https://nodejs.org/zh-cn/download/" target="_blank" rel="noopener">nodeJS</a>和git，并安装。  </p>
<p> nodeJS的path变量已经在安装程序里添加进去了。如果不放心可以自己手动添加环境变量：</p>
<ul>
<li><p>变量名： <code>NODE_PATH</code> ， 变量值为nodeJS安装路径（我的安装在E:\nodeJS）</p>
</li>
<li><p>编辑path，在变量值的最后添加： <code>%NODE_PATH%</code></p>
<p>检查nodeJS是否安装成功： win+R运行cmd，分别输入<code>node -v</code> 和<code>npm -v</code>，正确回显版本号表示安装成功。</p>
</li>
</ul>
</li>
<li><p>安装git bash</p>
</li>
<li><p>安装hexo</p>
<p> 在cmd窗口中输入<code>npm install -g hexo-cli</code>，将会把hexo安装到全局目录中。<br> 这一步回显有warning，但如果输入命令<code>hexo -v</code>回显版本号的话表示安装成功。</p>
</li>
</ol>
<h1 id="初始化博客框架"><a href="#初始化博客框架" class="headerlink" title="初始化博客框架"></a>初始化博客框架</h1><ol>
<li><p>新建一个空文件夹(如<code>E:\blog</code>)，在cmd窗口E:\blog目录下输入hexo init，自动生成初始化博客文件。<br>时间有一点长，中间安装dependency的时候显示了许多warning，先不管。</p>
</li>
<li><p>安装完成后，这个文件夹（也叫站点目录）的内容如下：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.  </span><br><span class="line">├── _config.yml  </span><br><span class="line">├── package.json  </span><br><span class="line">├── scaffolds  </span><br><span class="line">├── source  </span><br><span class="line">|&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;├── _drafts  </span><br><span class="line">|&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;└── _posts  </span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>hexo g</code>生成静态文件，<code>hexo s</code>启动本地服务器。在浏览器中输入<code>http://localhost:4000</code> 即可本地预览效果。</p>
</li>
<li><p>打开_config.yml，修改站点<a href="https://hexo.io/zh-cn/docs/configuration" target="_blank" rel="noopener">相关信息</a>。我改了site的那一段。</p>
</li>
<li><p>新建文章：</p>
<ul>
<li>输入命令<code>hexo new &quot;title&quot;</code>，会创建<code>source/_posts/title.md</code>  </li>
<li>生成文章或页面的模板放在博客文件夹根目录下的 <code>scaffolds/</code> 文件夹里面, 文章对应的是 <code>post.md</code> , 页面对应的是<code>page.md,</code> 草稿的是<code>draft.md</code></li>
<li>title是文章页面的显示名称，可任意修改不出现在url中；date文章日期一般不进行修改；categories文章分类目录，多个分类用中括号框起；tags文章标签，多个标签也用中括号框起。</li>
<li>设置文章预览摘要，只需在文章中适当位置增加<code>&lt;!--more--&gt;</code>，之前的内容即为预览摘要。</li>
</ul>
</li>
<li><p>安装博客主题(以NexT为例)</p>
<p> 只需要将主题文件拷贝至站点目录的 themes 目录下, 然后修改下配置文件即可。更多主题看<a href="https://www.zhihu.com/question/24422335" target="_blank" rel="noopener">知乎回答</a></p>
<ul>
<li>站点目录下 执行<code>git clone https://github.com/theme-next/hexo-theme-next themes/next</code></li>
<li>在站点目录的 _config.yml中查找字段<code>theme:</code>，改为<code>theme: next</code></li>
</ul>
</li>
<li><p>加入博客的搜索功能</p>
<ul>
<li><p>安装hexo-generator-searchdb: 站点目录执行<code>npm install hexo-generator-searchdb --save</code></p>
</li>
<li><p>在 <code>_config.yml</code>的末尾添加如下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">search:</span><br><span class="line"> path: search.xml  </span><br><span class="line"> field: post  </span><br><span class="line"> format: html  </span><br><span class="line"> limit: 10000</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>theme/next/_config.yml</code>中（当前启用主题的配置文件）修改<code>local_search</code>的<code>enable</code>字段为<code>true</code></p>
</li>
</ul>
</li>
</ol>
<h1 id="博客的修改与发布"><a href="#博客的修改与发布" class="headerlink" title="博客的修改与发布"></a>博客的修改与发布</h1><p>刚才已经预览过一次了，清除缓存： <code>hexo clean / hexo cl</code><br>生成静态文件: <code>hexo generate / hexo g</code><br>本地服务器启动： <code>hexo server / hexo s</code></p>
<h1 id="安装hexo-admin插件编辑博文"><a href="#安装hexo-admin插件编辑博文" class="headerlink" title="安装hexo-admin插件编辑博文"></a>安装hexo-admin插件编辑博文</h1><ol>
<li><p>站点目录下执行命令：<code>npm install --save hexo-admin</code></p>
</li>
<li><p>启动服务器 <code>hexo server -d</code>， 然后在浏览器端访问</p>
</li>
<li><p>修改根目录_config.yml文档中deploy的配置<br>文档末输入 :</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">admin:</span><br><span class="line">    deployCommand: hexo-publish.bat</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建bat文件： 站点根目录下新建hexo-publish.bat文件，文件内容如下：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo g -d</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="发布到github-pages"><a href="#发布到github-pages" class="headerlink" title="发布到github.pages"></a>发布到github.pages</h1><ol>
<li><p>安装hexo-deployer-git:<br>站点目录下执行：<code>npm install hexo-deployer-git --save</code></p>
</li>
<li><p>在自己的github账户里新建一个repository(比如<code>alenzhon.github.io</code>)。 这一步可以通过github desktop完成。</p>
</li>
<li><p>修改站点目录下 _config.yml的配置：<br>在deploy字段添加如下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  deploy:</span><br><span class="line">type: git</span><br><span class="line">repository: https:&#x2F;&#x2F;github.com&#x2F;AlenZhon&#x2F;alenzhon.github.io.git</span><br><span class="line">branch: master</span><br></pre></td></tr></table></figure></li>
<li><p>将本地的静态网页部署到服务器上: <code>hexo deploy/hexo d</code></p>
</li>
</ol>
<h1 id="TroubleShooting"><a href="#TroubleShooting" class="headerlink" title="TroubleShooting"></a>TroubleShooting</h1><p>一开始我github repository的名字是随便起的alenzone，然后就发现静态博客本地预览时没问题，但部署到github page上就出现问题了：只能显示首页的文本而没有用主题渲染。f12调试台发现JS文件请求都404了。<br>比对了一下，猜测JS文件的请求路径是alenzhon.github.io/js，而使用repository的话造成路径中多了”alenzhon.github.io/alenzone/js”。重新建了一个alenzhon.github.io的repo后重新部署，问题消失。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>添加图片等功能参考以下文章。</p>
<ol>
<li><a href="https://cymbym.github.io/2020/01/22/%E3%80%90Hexo%E3%80%91Hexo-github%E6%90%AD%E5%BB%BAgithub%E5%8D%9A%E5%AE%A2/" target="_blank" rel="noopener">【Hexo】Hexo+github搭建github博客 </a></li>
<li><a href="https://yangbingdong.com/2017/build-blog-hexo-base/" target="_blank" rel="noopener">https://yangbingdong.com/2017/build-blog-hexo-base/</a></li>
</ol>
]]></content>
      <categories>
        <category>helloworld</category>
      </categories>
      <tags>
        <tag>helloworld</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
