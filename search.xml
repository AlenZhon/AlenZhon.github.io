<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>SpringMVC 相关概念（二）参数绑定&amp;常用注解</title>
    <url>/2020/03/11/SpringMVC_01/</url>
    <content><![CDATA[<h2 id="SpringMVC请求参数的绑定"><a href="#SpringMVC请求参数的绑定" class="headerlink" title="SpringMVC请求参数的绑定"></a>SpringMVC请求参数的绑定</h2><p>浏览器把参数数据封装Request中发送给后台，后台Controller如何知道Request参数对应方法里的哪个参数？<br>常用方法：</p>
<ol>
<li>方法传入参数的名字和Request参数的名字完全一致。</li>
<li>在方法参数处使用<code>@RequestParam</code>绑定请求参数值，其中<code>value</code>/<code>name</code>属性是请求参数名， <code>require</code>表示请求参数是否必须，默认为true，<code>defaultValue</code>表示请求参数的默认值，不存在则抛出异常。</li>
<li>注解<code>@RequestMapping</code>接收参数。注解上的参数必须和请求参数相同。</li>
</ol>
<p>例如，Request发来的参数为一个<code>username</code>，下列方法都可以实现参数绑定</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"/testParam"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testParam</span><span class="params">(String username)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"/testParam"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testParam</span><span class="params">( @RequestParam(value = <span class="string">"username"</span>)</span>String username)</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"/testParam/&#123;username&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testParam</span><span class="params">(@PathVariable(<span class="string">"username"</span>)</span> String name)</span></span><br></pre></td></tr></table></figure>

<p>此外，也可以<br>4. 使用POJO对象将所有请求参数封装到对象中，要求对象中的属性包含所有请求参数且一一对应。<br>5. 使用原生的Servlet API 作为Controller 方法的参数。 如HttpServletRequest, HttpServletResponse</p>
<h3 id="解决表单传参数中文乱码的问题"><a href="#解决表单传参数中文乱码的问题" class="headerlink" title="解决表单传参数中文乱码的问题"></a>解决表单传参数中文乱码的问题</h3><p>在web.xml中配置字符过滤器。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--  配置字符过滤器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>characterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>characterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="自定义数据类型转换器"><a href="#自定义数据类型转换器" class="headerlink" title="自定义数据类型转换器"></a>自定义数据类型转换器</h3><p>MVC框架可以自动转换大部分基本数据类型，但某些自动转换会报错。例如String转Date，如果输入字符串”2020-1-1”则会报BAD REQUEST。</p>
<ol>
<li>首先写一个类型转换类，实现Converter接口。  </li>
<li>然后在xml中配置这个自定义类型转换器。  </li>
<li>最后配置自定义类型转换器生效 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span> <span class="attr">conversion-service</span>=<span class="string">"conversionService"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h2><ol>
<li>@RequestParam 修饰Controller方法参数<br> 参数绑定时已经有过详细介绍。</li>
<li>@RequestBody 修饰方法参数，直接获取请求体的内容。<br> 不适用GET（因为GET请求没有请求体）</li>
<li>@PathVariable 用于绑定url中的占位符，被视为支持RESTful风格。<br> 在参数绑定的第三个方法中使用。</li>
<li>@RequestHeader 修饰方法参数，获取请求头。</li>
<li>@CookieValue 获取指定Cookie的值</li>
<li>@ModelAttribute 出现在方法上，表示当前方法会在Controller方法执行前执行；出现在参数上表示获取指定数据给参数赋值。</li>
<li>@SessionAttribute 用于多次执行Controller方法的数据共享。</li>
</ol>
]]></content>
      <categories>
        <category>java</category>
        <category>springMVC</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>springMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC 相关概念</title>
    <url>/2020/03/10/SpringMVC/</url>
    <content><![CDATA[<p>了解一些SpringMVC的基本概念，并用一个入门程序加深理解。</p>
<h2 id="SpringMVC-入门"><a href="#SpringMVC-入门" class="headerlink" title="SpringMVC 入门"></a>SpringMVC 入门</h2><ol>
<li><p>服务器端的三层框架：表现层，业务层，持久层(SSM中分别对应SpringMVC, Spring, MyBatis)</p>
</li>
<li><p>MVC设计模型： Model模型（多用于封装数据），View视图（多用于展示数据），Controller控制器（处理程序逻辑）。是一种用于设计创建web应用程序表现成的模式</p>
</li>
<li><p>SpringMVC是基于MVC设计模型的轻量级web框架。其他的MVC开发框架有struts, struts2等。共同点：都是基于MVC模型表现层框架，底层离不开原始的ServletAPI，且处理请求的机制都是核心控制器。区别：MVC核心控制器是servlet，struts2基于过滤器。前者基于方法设计，后者基于类，每次执行时都创建一个动作类。struts2的OGNL表达式使开发效率高一些，但是执行效率和JSTL提升不大。</p>
</li>
</ol>
<h2 id="入门程序"><a href="#入门程序" class="headerlink" title="入门程序"></a>入门程序</h2><p>需求：web页面上有一个超链接，点击超链接可处理请求，并跳转到请求成功页面。开发步骤：搭建环境-&gt;代码</p>
<a id="more"></a>

<h3 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h3><ol>
<li>new project 时点选Create from archetype，点选<code>maven-archetype-webapp</code>创建项目。解决Maven加载过慢可添加键值对：archetypeCatalog internal（这个键值对的作用可看参考）。</li>
<li>在main文件夹中目录结构补完： java和resources文件夹。</li>
<li>引入依赖包。可以在<code>properties</code>字段里显式配置<code>spring.version</code>锁定使用版本。</li>
<li><code>web.xml</code>配前端控制器。配置servlet字段<code>DispatcherServlet</code>和servletMapping字段。</li>
<li>使用Tomcat启动服务器部署。之前没有下载tomcat，去下了一个tomcat 8.5.51。然后在run configuration里做相应配置。</li>
<li>Run，自动弹出默认浏览器显示HelloWorld。</li>
</ol>
<h3 id="代码修改"><a href="#代码修改" class="headerlink" title="代码修改"></a>代码修改</h3><ol>
<li><p>index.jsp页面上为防止中文乱码确定字符集为utf-8.在开头添加<code>&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;</code></p>
</li>
<li><p>创建<code>springMVC.xml</code>并开启注解扫描。</p>
</li>
<li><p>在servlet创建时加载springMVC.xml: 新增<code>&lt;init-param&gt;</code>提供全局初始化参数，在<code>&lt;contextConfigLocation&gt;</code>指定springMVC.xml的位置。并添加<code>&lt;load-on-startup&gt;</code>使服务器启动时加载配置文件</p>
 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springMVC.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>创建Controller类<code>HelloController</code>，开启@Controller注解和@RequestMapping注解，指定请求映射参数（与jsp页面的<code>“href”</code>相同).<br> 实现sayHello方法返回”success”字符串则默认跳转到”success.jsp”</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//控制器的类</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(path = <span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello SpringMVC!"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>创建跳转页面<code>success.jsp</code>，放在<code>WEB-INF/pages</code>目录下</p>
</li>
<li><p>在springMVC.xml配置文件中开启视图解析器<code>InternalResourceViewResolver</code>，自动解析页面地址；还开启了一个springMVC的注解支持(作用看后文)</p>
 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 视图解析器对象 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"internalResourceViewResolver"</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"prefix"</span> <span class="attr">value</span>=<span class="string">"WEB-INF/pages/"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suffix"</span> <span class="attr">value</span>=<span class="string">".jsp"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 开启SpringMVC注解支持--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>启动服务器，点击跳转，成功。</p>
</li>
</ol>
<h2 id="入门程序的运行流程分析"><a href="#入门程序的运行流程分析" class="headerlink" title="入门程序的运行流程分析"></a>入门程序的运行流程分析</h2><ol>
<li><p>启动服务器，加载配置文件</p>
<ul>
<li><code>load-on-startup</code>使得启动服务器时创建了<code>servlet</code>对象，同时加载了<code>springMVC.xml</code>配置文件。</li>
<li>由于配置文件中开启了注解扫描，将<code>Controller</code>类加载进IoC容器中生成<code>Singleton</code>对象。视图解析器也被配置成对象。</li>
<li><code>SpringMVC</code>注解支持使得<code>RequestMapping</code>注解生效。</li>
</ul>
</li>
<li><p>发送跳转请求，后台处理请求</p>
<ul>
<li>点击<code>index.jsp</code>上的超链接，<code>DispatcherSerlvet</code>前端控制器拦截请求。</li>
<li>请求查找 <code>HandlerMapping</code> 处理器映射器，处理器映射器返回handle方法</li>
<li>前端控制器请求 <code>HandlerAdapter</code> handler适配器，由handler处理器执行方法，再通过适配器返回ModelAndView（实际上返回视图页面<code>success.jsp</code>），</li>
<li>前端控制器请求视图解析器对象<code>InternalResourceViewResolver</code>，视图解析器返回View视图，再把模型数据填充到Request域。</li>
<li><code>DispatcherSerlvet</code>响应到浏览器。</li>
</ul>
</li>
</ol>
<h2 id="lt-mvc-annotation-driven-gt-的作用？"><a href="#lt-mvc-annotation-driven-gt-的作用？" class="headerlink" title="&lt;mvc:annotation-driven/&gt;的作用？"></a><code>&lt;mvc:annotation-driven/&gt;</code>的作用？</h2><p>处理器映射器，处理器适配器和视图解析器被称为SpringMVC的三大组件。<br>使用<code>&lt;mvc:annotation-driven/&gt;</code>可自动加载处理映射器<code>HandlerMapping</code>和处理适配器<code>HandlerAdapter</code>，简化注解配置</p>
<h2 id="RequestMapping注解"><a href="#RequestMapping注解" class="headerlink" title="RequestMapping注解"></a><code>RequestMapping</code>注解</h2><p><code>RequestMapping</code>注解既可以放在方法上，也可以放在类上。如果类上和方法上都进行<code>RequestMapping</code>注解，path可指定多级目录实现模块化开发。</p>
<p>常用属性：</p>
<ul>
<li><code>value</code> 表示请求的url，和path属性是一样的。（路径错误浏览器返回<code>404 PAGE NOT FOUND</code>）</li>
<li><code>method</code> 指当前方法可以接收什么请求方式（GET, POST），枚举类RequestMethod中定义了请求方式。(不在规定method中浏览器返回<code>405 METHOD NOT ALLOWED</code>)</li>
<li><code>params</code> 限制请求参数的条件。要求请求参数的key和value值和指定的params参数一模一样。(参数不对应浏览器返回<code>400 BAD REQUEST</code>)</li>
<li>headers 指定HTTP的特定请求头必须存在。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.cnblogs.com/taiguyiba/p/11727758.html" target="_blank" rel="noopener">archetypeCatalog=internal键值对的作用</a></li>
<li><a href="https://github.com/AlenZhon/SpringMVC_start" target="_blank" rel="noopener">入门程序详见我的Github</a></li>
</ul>
]]></content>
      <categories>
        <category>java</category>
        <category>springMVC</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>springMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven替换国内镜像</title>
    <url>/2020/03/10/MavenMirrorChange/</url>
    <content><![CDATA[<p>idea中Maven默认下载源的速度慢，每次下载jar包要import很久，所以想更换到国内镜像。</p>
<a id="more"></a>

<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>首先查看一下自己使用的Maven是IDEA自带的还是自己安装的。<br>IDEA –&gt; File –&gt; project settings –&gt; 搜索 Maven –&gt; 看Maven home directory那一栏。 发现我的显示是<code>Bundled (Maven 3)</code></p>
<p>win7环境，默认情况下在用户目录的.m2下自己新建setting文件。到User Setting File一栏的地址去打开<code>setting.xml</code>。修改为如下所示修改到阿里云镜像：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/SETTINGS/1.0.0"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/SETTINGS/1.0.0</span></span></span><br><span class="line"><span class="tag"><span class="string">                          https://maven.apache.org/xsd/settings-1.0.0.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrors</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果Maven home directory那一栏显示的是自定义的Maven安装路径，则打开Maven安装目录下<code>conf/settings.xml</code>。查找Mirror字段，修改为：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.cnblogs.com/draculaqk/p/7613807.html" target="_blank" rel="noopener">修改Intelij IDEA的maven依据下载为国内镜像（阿里）</a></li>
<li><a href="http://www.luyixian.cn/news_show_259457.aspx" target="_blank" rel="noopener">maven换源</a></li>
</ul>
]]></content>
      <categories>
        <category>java</category>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Overview</title>
    <url>/2020/03/10/Spring00/</url>
    <content><![CDATA[<p>了解一些Spring框架的相关概念并做简单记录。</p>
<h2 id="整体"><a href="#整体" class="headerlink" title="整体"></a>整体</h2><ol>
<li>Spring 开源框架，三个特性：IoC Inversion of Control控制反转，程序员对对象的创建和控制交由Spring容器，DL依赖注入（依赖注入是IoC的实现方式）， AoP面向切片编程。</li>
<li>模块化，大约有20个模块。核心容器(<code>Core Container</code>)由<code>spring-core，spring-beans，spring-context，spring-context-support</code>和<code>spEL</code>组成，数据访问/集成层包括 <code>JDBC，ORM，OXM，JMS</code> 和事务处理模块，Web 层由 <code>Web，Web-MVC，Web-Socket</code> 和 <code>Web-Portlet</code> 组成，还有其他一些重要的模块，像 <code>AOP，Aspects，Instrumentation</code> 和测试模块。</li>
</ol>
<a id="more"></a>

<h2 id="Spring-bean"><a href="#Spring-bean" class="headerlink" title="Spring bean"></a>Spring bean</h2><ol start="3">
<li><code>Application Context</code> 是 <code>BeanFactory</code> 的子接口，也被称为 Spring 上下文。</li>
<li>bean 是一个被实例化，组装，并通过 Spring IoC 容器所管理的对象。SpringIoC容器可通过三种方式配置bean：<strong>基于XML配置文件，基于注解，基于Java配置</strong>。下面基于XML进行Bean参数(<code>id, class, scope, init-method, destroy-method</code>)的说明。</li>
<li>创建bean的三种方式：使用构造器创建，使用静态工厂创建，使用实例工厂创建。</li>
<li>Spring 框架支持以下五个bean作用域(scope = )，分别为<code>singleton(默认)、prototype、request、session和global session</code>。如果每次调用<code>getBean</code>都是获取同一个实例则需要声明作用域为<code>singleton</code>，如果每次调用都<code>new</code>一个实例则声明为<code>prototype</code>。使用 web-aware ApplicationContext时，<code>request</code>表示每次HTTP请求都new一个实例，<code>session</code>表示同一个session共享同个实例，<code>global session</code>一般用于Portlet应用环境。</li>
<li>Bean可由<code>init-method</code>和<code>destroy-method</code>参数定义初始化回调方法和销毁回调方法。如果许多Bean中的初始化方法和销毁方法相同，可以直接写到beans的配置中，利用<code>default-init-method</code> 和 <code>default-destroy-method</code>属性完成初始化和销毁方法的声明。</li>
<li>Bean的继承：子 bean继承了父定义的配置数据，通过parent参数进行声明。Bean的继承与java的继承无关，不需要对应的两个java类用extend关键字继承，但需要子类要继承的属性和父类相同。</li>
<li>可定义Bean模板，使得其他Bean的定义从模板继承。模板不声明class属性而是声明<code>abstract=”true”</code>。</li>
</ol>
<h2 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h2><ol start="10">
<li>依赖注入：依赖类不由程序员实例化，而是通过spring容器帮我们new指定实例并且将实例注入到需要该对象的类。常用有：<strong>构造方法注入，set方法参数注入，基于注解@Autowired注入</strong>。</li>
<li><strong>构造方法注入</strong>；当容器调用带有一组参数的类构造函数时，基于构造函数的 DI 就完成了，其中每个参数代表一个对其他类的依赖。XML配置文件中使用<code>constructor-arg</code>。如果构造函数参数有多个，则要在配置文件中按顺序给出/在后面添加<code>index</code>标签显式指定参数索引值。<code>ref</code>传递引用（依赖类），<code>value</code>传递值（基本数据类型或成员属性）。</li>
<li><strong>Setter注入</strong>：当容器调用无参构造函数时，通过容器调用setter函数完成依赖注入。XML配置文件中使用<code>property</code>标签。</li>
<li><strong>@Autowired注入</strong>：Bean类依赖注入对象的setter函数或构造函数前加上<code>@Autowired</code>。默认情况下<code>@Autowired</code>是按类型匹配的(byType)。XML配置文件中要添加一行<code>&lt;context:annotation-config/&gt;</code>。</li>
<li><code>&lt;context:annotation-config/&gt;</code>：仅能够在已经在已经注册过的bean上面起作用。对于没有在spring容器中注册的bean，它并不能执行任何操作。<br><code>&lt;context:component-scan base-package=&quot;XX.XX&quot;/&gt;</code> ：除了具有上面的功能之外，还具有自动将带有<code>@component, @service, @Repository</code>等注解的对象注册到spring容器中的功能。</li>
<li><strong>@Required</strong> 注解应用于 bean 属性的 setter 方法，它表明受影响的 bean 属性在配置时必须放在 XML文件中，否则容器就会抛出<code>BeanInitializationException</code> 异常。</li>
<li>当使用<code>@Autowired</code> 标注setter方法时，默认采用byType自动装配策略。在这种策略下，符合自动装配类型的候选Bean实例常常有多个，这个时候就可能引起异常，为了实现精确的自动装配，Spring提供了 <strong>@Qualifier</strong> 注解，通过使用<code>@Qualifier</code>，允许根据Bean的id来执行自动装配</li>
<li>inner beans 是在其他 bean 的范围内定义的 bean。类似Java内部类的概念。</li>
<li>注入集合对象：使用<code>&lt;list&gt; &lt;set&gt; &lt;map&gt; &lt;props&gt;</code>分别表示<code>list, set, map, properties</code>其中<code>properties</code>要求<code>key</code>和<code>value</code>都是字符串类型而<code>map</code>不要求类型。</li>
</ol>
<h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><ol start="19">
<li><strong>事件处理</strong>：Spring提供<code>ApplicationListener</code> 接口实现事件管理。一个实现这个接口的事件类应实现一个<code>onApplicationEvent</code>方法。Main方法中<code>context</code>为<code>ConfigurableApplicationContext</code>的实例。Spring 的事件处理是单线程的，所以如果一个事件被发布，直至并且除非所有的接收者得到的该消息，该进程被阻塞并且流程将不会继续。</li>
<li><strong>自定义事件处理</strong>：继承<code>ApplicationEvent</code>类，同时必须定义默认构造函数。</li>
</ol>
<h2 id="AoP"><a href="#AoP" class="headerlink" title="AoP"></a>AoP</h2><ol start="21">
<li>Spring框架的AOP机制可以让开发者把业务流程中的通用功能抽取出来，单独编写功能代码。在业务流程执行过程中，Spring框架会根据业务流程要求，自动把独立编写的功能代码切入到流程的合适位置。</li>
<li><strong>切面（<code>Aspect</code>）</strong>：一个关注点的模块化，这个关注点可能会横切多个对象。事务管理是J2EE应用中一个关于横切关注点的很好的例子。<strong>连接点（<code>JointPoint</code>）</strong>表示业务流程在运行过程中需要插入切面的具体位置（方法）。<strong>通知（<code>Advice</code>）</strong>：在切面的某个特定的连接点上执行的动作。<strong>切点（<code>Pointcut</code>）</strong>：用于定义通知应该切入到哪些连接点上，不同的通知通常需要切入到不同的连接点上。<strong>目标对象（<code>Target</code>）</strong>：被一个或者多个切面所通知的对象。<strong>代理（<code>Proxy</code>）</strong>：目标对象的业务逻辑功能加上被切入的切面所形成的对象。<strong>织入（<code>Weaving</code>）</strong>：把切面连接到其它的应用程序类型或者对象上，并创建一个被通知的对象。这个过程可以发生在编译期、类装载期及运行期。</li>
<li>通知类型：<code>Before Advice/After Returning/After throwing/After (finally)/Around advice</code></li>
<li>在Spring AOP中，切面可以使用基于XML配置或者基于<code>@Aspect</code>注解的方式来实现。 需要在 pom.xml 里导入依赖包<code>aspectjrt</code>和 <code>aspectjweaver</code>。</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>中文资料感觉都不新。</p>
<ul>
<li><a href="https://www.docs4dev.com/docs/zh/spring-framework/4.3.21.RELEASE/reference/overview-getting-started-with-spring.html#spring-%E5%85%A5%E9%97%A8" target="_blank" rel="noopener">Spring Framework中文文档(机翻味道浓，有时间建议看英文)</a></li>
<li><a href="https://www.w3cschool.cn/wkspring/pesy1icl.html" target="_blank" rel="noopener">w3cschool的spring教程</a></li>
<li><a href="https://wiki.jikexueyuan.com/project/spring/" target="_blank" rel="noopener">极客学院的spring教程</a></li>
</ul>
]]></content>
      <categories>
        <category>java</category>
        <category>spring</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/03/08/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<a id="more"></a>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
      <categories>
        <category>helloworld</category>
      </categories>
      <tags>
        <tag>helloworld</tag>
      </tags>
  </entry>
  <entry>
    <title>利用Hexo在github上搭建静态个人博客</title>
    <url>/2020/03/08/hexo/</url>
    <content><![CDATA[<h1 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h1><p><a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo</a> 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。<br>需要先安装Git和nodeJS。</p>
<a id="more"></a>


<h1 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h1><ol>
<li><p>首先去下载<a href="https://nodejs.org/zh-cn/download/" target="_blank" rel="noopener">nodeJS</a>和git，并安装。  </p>
<p> nodeJS的path变量已经在安装程序里添加进去了。如果不放心可以自己手动添加环境变量：</p>
<ul>
<li><p>变量名： <code>NODE_PATH</code> ， 变量值为nodeJS安装路径（我的安装在E:\nodeJS）</p>
</li>
<li><p>编辑path，在变量值的最后添加： <code>%NODE_PATH%</code></p>
<p>检查nodeJS是否安装成功： win+R运行cmd，分别输入<code>node -v</code> 和<code>npm -v</code>，正确回显版本号表示安装成功。</p>
</li>
</ul>
</li>
<li><p>安装git bash</p>
</li>
<li><p>安装hexo</p>
<p> 在cmd窗口中输入<code>npm install -g hexo-cli</code>，将会把hexo安装到全局目录中。<br> 这一步回显有warning，但如果输入命令<code>hexo -v</code>回显版本号的话表示安装成功。</p>
</li>
</ol>
<h1 id="初始化博客框架"><a href="#初始化博客框架" class="headerlink" title="初始化博客框架"></a>初始化博客框架</h1><ol>
<li><p>新建一个空文件夹(如<code>E:\blog</code>)，在cmd窗口E:\blog目录下输入hexo init，自动生成初始化博客文件。<br>时间有一点长，中间安装dependency的时候显示了许多warning，先不管。</p>
</li>
<li><p>安装完成后，这个文件夹（也叫站点目录）的内容如下：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.  </span><br><span class="line">├── _config.yml  </span><br><span class="line">├── package.json  </span><br><span class="line">├── scaffolds  </span><br><span class="line">├── source  </span><br><span class="line">|&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;├── _drafts  </span><br><span class="line">|&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;└── _posts  </span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>hexo g</code>生成静态文件，<code>hexo s</code>启动本地服务器。在浏览器中输入<code>http://localhost:4000</code> 即可本地预览效果。</p>
</li>
<li><p>打开_config.yml，修改站点<a href="https://hexo.io/zh-cn/docs/configuration" target="_blank" rel="noopener">相关信息</a>。我改了site的那一段。</p>
</li>
<li><p>新建文章：</p>
<ul>
<li>输入命令<code>hexo new &quot;title&quot;</code>，会创建<code>source/_posts/title.md</code>  </li>
<li>生成文章或页面的模板放在博客文件夹根目录下的 <code>scaffolds/</code> 文件夹里面, 文章对应的是 <code>post.md</code> , 页面对应的是<code>page.md,</code> 草稿的是<code>draft.md</code></li>
<li>title是文章页面的显示名称，可任意修改不出现在url中；date文章日期一般不进行修改；categories文章分类目录，多个分类用中括号框起；tags文章标签，多个标签也用中括号框起。</li>
<li>设置文章预览摘要，只需在文章中适当位置增加<code>&lt;!--more--&gt;</code>，之前的内容即为预览摘要。</li>
</ul>
</li>
<li><p>安装博客主题(以NexT为例)</p>
<p> 只需要将主题文件拷贝至站点目录的 themes 目录下, 然后修改下配置文件即可。更多主题看<a href="https://www.zhihu.com/question/24422335" target="_blank" rel="noopener">知乎回答</a></p>
<ul>
<li>站点目录下 执行<code>git clone https://github.com/theme-next/hexo-theme-next themes/next</code></li>
<li>在站点目录的 _config.yml中查找字段<code>theme:</code>，改为<code>theme: next</code></li>
</ul>
</li>
<li><p>加入博客的搜索功能</p>
<ul>
<li><p>安装hexo-generator-searchdb: 站点目录执行<code>npm install hexo-generator-searchdb --save</code></p>
</li>
<li><p>在 <code>_config.yml</code>的末尾添加如下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">search:</span><br><span class="line"> path: search.xml  </span><br><span class="line"> field: post  </span><br><span class="line"> format: html  </span><br><span class="line"> limit: 10000</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>theme/next/_config.yml</code>中（当前启用主题的配置文件）修改<code>local_search</code>的<code>enable</code>字段为<code>true</code></p>
</li>
</ul>
</li>
</ol>
<h1 id="博客的修改与发布"><a href="#博客的修改与发布" class="headerlink" title="博客的修改与发布"></a>博客的修改与发布</h1><p>刚才已经预览过一次了，清除缓存： <code>hexo clean / hexo cl</code><br>生成静态文件: <code>hexo generate / hexo g</code><br>本地服务器启动： <code>hexo server / hexo s</code></p>
<h1 id="安装hexo-admin插件编辑博文"><a href="#安装hexo-admin插件编辑博文" class="headerlink" title="安装hexo-admin插件编辑博文"></a>安装hexo-admin插件编辑博文</h1><ol>
<li><p>站点目录下执行命令：<code>npm install --save hexo-admin</code></p>
</li>
<li><p>启动服务器 <code>hexo server -d</code>， 然后在浏览器端访问</p>
</li>
<li><p>修改根目录_config.yml文档中deploy的配置<br>文档末输入 :</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">admin:</span><br><span class="line">    deployCommand: hexo-publish.bat</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建bat文件： 站点根目录下新建hexo-publish.bat文件，文件内容如下：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo g -d</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="发布到github-pages"><a href="#发布到github-pages" class="headerlink" title="发布到github.pages"></a>发布到github.pages</h1><ol>
<li><p>安装hexo-deployer-git:<br>站点目录下执行：<code>npm install hexo-deployer-git --save</code></p>
</li>
<li><p>在自己的github账户里新建一个repository(比如<code>alenzhon.github.io</code>)。 这一步可以通过github desktop完成。</p>
</li>
<li><p>修改站点目录下 _config.yml的配置：<br>在deploy字段添加如下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  deploy:</span><br><span class="line">type: git</span><br><span class="line">repository: https:&#x2F;&#x2F;github.com&#x2F;AlenZhon&#x2F;alenzhon.github.io.git</span><br><span class="line">branch: master</span><br></pre></td></tr></table></figure></li>
<li><p>将本地的静态网页部署到服务器上: <code>hexo deploy/hexo d</code></p>
</li>
</ol>
<h1 id="TroubleShooting"><a href="#TroubleShooting" class="headerlink" title="TroubleShooting"></a>TroubleShooting</h1><p>一开始我github repository的名字是随便起的alenzone，然后就发现静态博客本地预览时没问题，但部署到github page上就出现问题了：只能显示首页的文本而没有用主题渲染。f12调试台发现JS文件请求都404了。<br>比对了一下，猜测JS文件的请求路径是alenzhon.github.io/js，而使用repository的话造成路径中多了”alenzhon.github.io/alenzone/js”。重新建了一个alenzhon.github.io的repo后重新部署，问题消失。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>添加图片等功能参考以下文章。</p>
<ol>
<li><a href="https://cymbym.github.io/2020/01/22/%E3%80%90Hexo%E3%80%91Hexo-github%E6%90%AD%E5%BB%BAgithub%E5%8D%9A%E5%AE%A2/" target="_blank" rel="noopener">【Hexo】Hexo+github搭建github博客 </a></li>
<li><a href="https://yangbingdong.com/2017/build-blog-hexo-base/" target="_blank" rel="noopener">https://yangbingdong.com/2017/build-blog-hexo-base/</a></li>
</ol>
]]></content>
      <categories>
        <category>helloworld</category>
      </categories>
      <tags>
        <tag>helloworld</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
